// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: midimessage.proto

#ifndef PROTOBUF_INCLUDED_midimessage_2eproto
#define PROTOBUF_INCLUDED_midimessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_midimessage_2eproto 

namespace protobuf_midimessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_midimessage_2eproto
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class MessageMetadata;
class MessageMetadataDefaultTypeInternal;
extern MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;
class MidiData;
class MidiDataDefaultTypeInternal;
extern MidiDataDefaultTypeInternal _MidiData_default_instance_;
class MidiMessage;
class MidiMessageDefaultTypeInternal;
extern MidiMessageDefaultTypeInternal _MidiMessage_default_instance_;
class PortDescription;
class PortDescriptionDefaultTypeInternal;
extern PortDescriptionDefaultTypeInternal _PortDescription_default_instance_;
class PortList;
class PortListDefaultTypeInternal;
extern PortListDefaultTypeInternal _PortList_default_instance_;
class PublishedMessage;
class PublishedMessageDefaultTypeInternal;
extern PublishedMessageDefaultTypeInternal _PublishedMessage_default_instance_;
class SubscribeRequest;
class SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
namespace google {
namespace protobuf {
template<> ::Error* Arena::CreateMaybeMessage<::Error>(Arena*);
template<> ::MessageMetadata* Arena::CreateMaybeMessage<::MessageMetadata>(Arena*);
template<> ::MidiData* Arena::CreateMaybeMessage<::MidiData>(Arena*);
template<> ::MidiMessage* Arena::CreateMaybeMessage<::MidiMessage>(Arena*);
template<> ::PortDescription* Arena::CreateMaybeMessage<::PortDescription>(Arena*);
template<> ::PortList* Arena::CreateMaybeMessage<::PortList>(Arena*);
template<> ::PublishedMessage* Arena::CreateMaybeMessage<::PublishedMessage>(Arena*);
template<> ::SubscribeRequest* Arena::CreateMaybeMessage<::SubscribeRequest>(Arena*);
}  // namespace protobuf
}  // namespace google

enum PortDescription_Direction {
  PortDescription_Direction_IN = 0,
  PortDescription_Direction_OUT = 1,
  PortDescription_Direction_INOUT = 2,
  PortDescription_Direction_PortDescription_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PortDescription_Direction_PortDescription_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PortDescription_Direction_IsValid(int value);
const PortDescription_Direction PortDescription_Direction_Direction_MIN = PortDescription_Direction_IN;
const PortDescription_Direction PortDescription_Direction_Direction_MAX = PortDescription_Direction_INOUT;
const int PortDescription_Direction_Direction_ARRAYSIZE = PortDescription_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* PortDescription_Direction_descriptor();
inline const ::std::string& PortDescription_Direction_Name(PortDescription_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    PortDescription_Direction_descriptor(), value);
}
inline bool PortDescription_Direction_Parse(
    const ::std::string& name, PortDescription_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortDescription_Direction>(
    PortDescription_Direction_descriptor(), name, value);
}
enum Error_ErrorSeverity {
  Error_ErrorSeverity_DEPRECATION = 0,
  Error_ErrorSeverity_WARNING = 1,
  Error_ErrorSeverity_ERROR = 2,
  Error_ErrorSeverity_CATASTROPHE = 3,
  Error_ErrorSeverity_Error_ErrorSeverity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Error_ErrorSeverity_Error_ErrorSeverity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Error_ErrorSeverity_IsValid(int value);
const Error_ErrorSeverity Error_ErrorSeverity_ErrorSeverity_MIN = Error_ErrorSeverity_DEPRECATION;
const Error_ErrorSeverity Error_ErrorSeverity_ErrorSeverity_MAX = Error_ErrorSeverity_CATASTROPHE;
const int Error_ErrorSeverity_ErrorSeverity_ARRAYSIZE = Error_ErrorSeverity_ErrorSeverity_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_ErrorSeverity_descriptor();
inline const ::std::string& Error_ErrorSeverity_Name(Error_ErrorSeverity value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_ErrorSeverity_descriptor(), value);
}
inline bool Error_ErrorSeverity_Parse(
    const ::std::string& name, Error_ErrorSeverity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_ErrorSeverity>(
    Error_ErrorSeverity_descriptor(), name, value);
}
enum MidiMessage_MessageTypes {
  MidiMessage_MessageTypes_HOST_ANNOUNCE = 0,
  MidiMessage_MessageTypes_HOST_RETIRE = 1,
  MidiMessage_MessageTypes_RESEND_REQUESTED = 2,
  MidiMessage_MessageTypes_ERROR = 3,
  MidiMessage_MessageTypes_MIDI_DATA = 4,
  MidiMessage_MessageTypes_ACK = 5,
  MidiMessage_MessageTypes_PORT_REQUEST = 6,
  MidiMessage_MessageTypes_PUBLISHED_MESSAGE = 7,
  MidiMessage_MessageTypes_SUBSCRIBE_REQUEST = 8,
  MidiMessage_MessageTypes_MidiMessage_MessageTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MidiMessage_MessageTypes_MidiMessage_MessageTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MidiMessage_MessageTypes_IsValid(int value);
const MidiMessage_MessageTypes MidiMessage_MessageTypes_MessageTypes_MIN = MidiMessage_MessageTypes_HOST_ANNOUNCE;
const MidiMessage_MessageTypes MidiMessage_MessageTypes_MessageTypes_MAX = MidiMessage_MessageTypes_SUBSCRIBE_REQUEST;
const int MidiMessage_MessageTypes_MessageTypes_ARRAYSIZE = MidiMessage_MessageTypes_MessageTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* MidiMessage_MessageTypes_descriptor();
inline const ::std::string& MidiMessage_MessageTypes_Name(MidiMessage_MessageTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    MidiMessage_MessageTypes_descriptor(), value);
}
inline bool MidiMessage_MessageTypes_Parse(
    const ::std::string& name, MidiMessage_MessageTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MidiMessage_MessageTypes>(
    MidiMessage_MessageTypes_descriptor(), name, value);
}
// ===================================================================

class PortDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PortDescription) */ {
 public:
  PortDescription();
  virtual ~PortDescription();

  PortDescription(const PortDescription& from);

  inline PortDescription& operator=(const PortDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortDescription(PortDescription&& from) noexcept
    : PortDescription() {
    *this = ::std::move(from);
  }

  inline PortDescription& operator=(PortDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortDescription* internal_default_instance() {
    return reinterpret_cast<const PortDescription*>(
               &_PortDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PortDescription* other);
  friend void swap(PortDescription& a, PortDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortDescription* New() const final {
    return CreateMaybeMessage<PortDescription>(NULL);
  }

  PortDescription* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PortDescription>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PortDescription& from);
  void MergeFrom(const PortDescription& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PortDescription_Direction Direction;
  static const Direction IN =
    PortDescription_Direction_IN;
  static const Direction OUT =
    PortDescription_Direction_OUT;
  static const Direction INOUT =
    PortDescription_Direction_INOUT;
  static inline bool Direction_IsValid(int value) {
    return PortDescription_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    PortDescription_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    PortDescription_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    PortDescription_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return PortDescription_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return PortDescription_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return PortDescription_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .PortDescription.Direction direction = 1;
  void clear_direction();
  static const int kDirectionFieldNumber = 1;
  ::PortDescription_Direction direction() const;
  void set_direction(::PortDescription_Direction value);

  // bool create_dynamic = 3;
  void clear_create_dynamic();
  static const int kCreateDynamicFieldNumber = 3;
  bool create_dynamic() const;
  void set_create_dynamic(bool value);

  // int32 key = 4;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  ::google::protobuf::int32 key() const;
  void set_key(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PortDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int direction_;
  bool create_dynamic_;
  ::google::protobuf::int32 key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PortList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PortList) */ {
 public:
  PortList();
  virtual ~PortList();

  PortList(const PortList& from);

  inline PortList& operator=(const PortList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortList(PortList&& from) noexcept
    : PortList() {
    *this = ::std::move(from);
  }

  inline PortList& operator=(PortList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortList* internal_default_instance() {
    return reinterpret_cast<const PortList*>(
               &_PortList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PortList* other);
  friend void swap(PortList& a, PortList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortList* New() const final {
    return CreateMaybeMessage<PortList>(NULL);
  }

  PortList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PortList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PortList& from);
  void MergeFrom(const PortList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PortDescription ports = 1;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 1;
  ::PortDescription* mutable_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::PortDescription >*
      mutable_ports();
  const ::PortDescription& ports(int index) const;
  ::PortDescription* add_ports();
  const ::google::protobuf::RepeatedPtrField< ::PortDescription >&
      ports() const;

  // @@protoc_insertion_point(class_scope:PortList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::PortDescription > ports_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PublishedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PublishedMessage) */ {
 public:
  PublishedMessage();
  virtual ~PublishedMessage();

  PublishedMessage(const PublishedMessage& from);

  inline PublishedMessage& operator=(const PublishedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PublishedMessage(PublishedMessage&& from) noexcept
    : PublishedMessage() {
    *this = ::std::move(from);
  }

  inline PublishedMessage& operator=(PublishedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PublishedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PublishedMessage* internal_default_instance() {
    return reinterpret_cast<const PublishedMessage*>(
               &_PublishedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PublishedMessage* other);
  friend void swap(PublishedMessage& a, PublishedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PublishedMessage* New() const final {
    return CreateMaybeMessage<PublishedMessage>(NULL);
  }

  PublishedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PublishedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PublishedMessage& from);
  void MergeFrom(const PublishedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // string sender = 2;
  void clear_sender();
  static const int kSenderFieldNumber = 2;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // bytes message = 3;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:PublishedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubscribeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SubscribeRequest) */ {
 public:
  SubscribeRequest();
  virtual ~SubscribeRequest();

  SubscribeRequest(const SubscribeRequest& from);

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SubscribeRequest* other);
  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscribeRequest* New() const final {
    return CreateMaybeMessage<SubscribeRequest>(NULL);
  }

  SubscribeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubscribeRequest& from);
  void MergeFrom(const SubscribeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // string requestNode = 2;
  void clear_requestnode();
  static const int kRequestNodeFieldNumber = 2;
  const ::std::string& requestnode() const;
  void set_requestnode(const ::std::string& value);
  #if LANG_CXX11
  void set_requestnode(::std::string&& value);
  #endif
  void set_requestnode(const char* value);
  void set_requestnode(const char* value, size_t size);
  ::std::string* mutable_requestnode();
  ::std::string* release_requestnode();
  void set_allocated_requestnode(::std::string* requestnode);

  // bool is_subscription = 3;
  void clear_is_subscription();
  static const int kIsSubscriptionFieldNumber = 3;
  bool is_subscription() const;
  void set_is_subscription(bool value);

  // @@protoc_insertion_point(class_scope:SubscribeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr requestnode_;
  bool is_subscription_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageMetadata) */ {
 public:
  MessageMetadata();
  virtual ~MessageMetadata();

  MessageMetadata(const MessageMetadata& from);

  inline MessageMetadata& operator=(const MessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageMetadata(MessageMetadata&& from) noexcept
    : MessageMetadata() {
    *this = ::std::move(from);
  }

  inline MessageMetadata& operator=(MessageMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageMetadata* internal_default_instance() {
    return reinterpret_cast<const MessageMetadata*>(
               &_MessageMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MessageMetadata* other);
  friend void swap(MessageMetadata& a, MessageMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageMetadata* New() const final {
    return CreateMaybeMessage<MessageMetadata>(NULL);
  }

  MessageMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageMetadata& from);
  void MergeFrom(const MessageMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string host = 2;
  void clear_host();
  static const int kHostFieldNumber = 2;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // string friendly_name = 3;
  void clear_friendly_name();
  static const int kFriendlyNameFieldNumber = 3;
  const ::std::string& friendly_name() const;
  void set_friendly_name(const ::std::string& value);
  #if LANG_CXX11
  void set_friendly_name(::std::string&& value);
  #endif
  void set_friendly_name(const char* value);
  void set_friendly_name(const char* value, size_t size);
  ::std::string* mutable_friendly_name();
  ::std::string* release_friendly_name();
  void set_allocated_friendly_name(::std::string* friendly_name);

  // string software_package = 5;
  void clear_software_package();
  static const int kSoftwarePackageFieldNumber = 5;
  const ::std::string& software_package() const;
  void set_software_package(const ::std::string& value);
  #if LANG_CXX11
  void set_software_package(::std::string&& value);
  #endif
  void set_software_package(const char* value);
  void set_software_package(const char* value, size_t size);
  ::std::string* mutable_software_package();
  ::std::string* release_software_package();
  void set_allocated_software_package(::std::string* software_package);

  // string software_version = 6;
  void clear_software_version();
  static const int kSoftwareVersionFieldNumber = 6;
  const ::std::string& software_version() const;
  void set_software_version(const ::std::string& value);
  #if LANG_CXX11
  void set_software_version(::std::string&& value);
  #endif
  void set_software_version(const char* value);
  void set_software_version(const char* value, size_t size);
  ::std::string* mutable_software_version();
  ::std::string* release_software_version();
  void set_allocated_software_version(::std::string* software_version);

  // .PortList ports = 7;
  bool has_ports() const;
  void clear_ports();
  static const int kPortsFieldNumber = 7;
  private:
  const ::PortList& _internal_ports() const;
  public:
  const ::PortList& ports() const;
  ::PortList* release_ports();
  ::PortList* mutable_ports();
  void set_allocated_ports(::PortList* ports);

  // uint32 port = 1;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // bool is_master = 4;
  void clear_is_master();
  static const int kIsMasterFieldNumber = 4;
  bool is_master() const;
  void set_is_master(bool value);

  // @@protoc_insertion_point(class_scope:MessageMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr friendly_name_;
  ::google::protobuf::internal::ArenaStringPtr software_package_;
  ::google::protobuf::internal::ArenaStringPtr software_version_;
  ::PortList* ports_;
  ::google::protobuf::uint32 port_;
  bool is_master_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(NULL);
  }

  Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Error_ErrorSeverity ErrorSeverity;
  static const ErrorSeverity DEPRECATION =
    Error_ErrorSeverity_DEPRECATION;
  static const ErrorSeverity WARNING =
    Error_ErrorSeverity_WARNING;
  static const ErrorSeverity ERROR =
    Error_ErrorSeverity_ERROR;
  static const ErrorSeverity CATASTROPHE =
    Error_ErrorSeverity_CATASTROPHE;
  static inline bool ErrorSeverity_IsValid(int value) {
    return Error_ErrorSeverity_IsValid(value);
  }
  static const ErrorSeverity ErrorSeverity_MIN =
    Error_ErrorSeverity_ErrorSeverity_MIN;
  static const ErrorSeverity ErrorSeverity_MAX =
    Error_ErrorSeverity_ErrorSeverity_MAX;
  static const int ErrorSeverity_ARRAYSIZE =
    Error_ErrorSeverity_ErrorSeverity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorSeverity_descriptor() {
    return Error_ErrorSeverity_descriptor();
  }
  static inline const ::std::string& ErrorSeverity_Name(ErrorSeverity value) {
    return Error_ErrorSeverity_Name(value);
  }
  static inline bool ErrorSeverity_Parse(const ::std::string& name,
      ErrorSeverity* value) {
    return Error_ErrorSeverity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string error_type = 1;
  void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  const ::std::string& error_type() const;
  void set_error_type(const ::std::string& value);
  #if LANG_CXX11
  void set_error_type(::std::string&& value);
  #endif
  void set_error_type(const char* value);
  void set_error_type(const char* value, size_t size);
  ::std::string* mutable_error_type();
  ::std::string* release_error_type();
  void set_allocated_error_type(::std::string* error_type);

  // .Error.ErrorSeverity severity = 2;
  void clear_severity();
  static const int kSeverityFieldNumber = 2;
  ::Error_ErrorSeverity severity() const;
  void set_severity(::Error_ErrorSeverity value);

  // @@protoc_insertion_point(class_scope:Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_type_;
  int severity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MidiData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MidiData) */ {
 public:
  MidiData();
  virtual ~MidiData();

  MidiData(const MidiData& from);

  inline MidiData& operator=(const MidiData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MidiData(MidiData&& from) noexcept
    : MidiData() {
    *this = ::std::move(from);
  }

  inline MidiData& operator=(MidiData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MidiData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MidiData* internal_default_instance() {
    return reinterpret_cast<const MidiData*>(
               &_MidiData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MidiData* other);
  friend void swap(MidiData& a, MidiData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MidiData* New() const final {
    return CreateMaybeMessage<MidiData>(NULL);
  }

  MidiData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MidiData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MidiData& from);
  void MergeFrom(const MidiData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MidiData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 channel = 1;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MidiData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 channel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MidiMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MidiMessage) */ {
 public:
  MidiMessage();
  virtual ~MidiMessage();

  MidiMessage(const MidiMessage& from);

  inline MidiMessage& operator=(const MidiMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MidiMessage(MidiMessage&& from) noexcept
    : MidiMessage() {
    *this = ::std::move(from);
  }

  inline MidiMessage& operator=(MidiMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MidiMessage& default_instance();

  enum PayloadCase {
    kMessageMetadata = 6,
    kError = 7,
    kMidiData = 8,
    kAckedMessage = 9,
    kPorts = 10,
    kPublishedMessage = 11,
    kSubscribeRequest = 12,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MidiMessage* internal_default_instance() {
    return reinterpret_cast<const MidiMessage*>(
               &_MidiMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MidiMessage* other);
  friend void swap(MidiMessage& a, MidiMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MidiMessage* New() const final {
    return CreateMaybeMessage<MidiMessage>(NULL);
  }

  MidiMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MidiMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MidiMessage& from);
  void MergeFrom(const MidiMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MidiMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MidiMessage_MessageTypes MessageTypes;
  static const MessageTypes HOST_ANNOUNCE =
    MidiMessage_MessageTypes_HOST_ANNOUNCE;
  static const MessageTypes HOST_RETIRE =
    MidiMessage_MessageTypes_HOST_RETIRE;
  static const MessageTypes RESEND_REQUESTED =
    MidiMessage_MessageTypes_RESEND_REQUESTED;
  static const MessageTypes ERROR =
    MidiMessage_MessageTypes_ERROR;
  static const MessageTypes MIDI_DATA =
    MidiMessage_MessageTypes_MIDI_DATA;
  static const MessageTypes ACK =
    MidiMessage_MessageTypes_ACK;
  static const MessageTypes PORT_REQUEST =
    MidiMessage_MessageTypes_PORT_REQUEST;
  static const MessageTypes PUBLISHED_MESSAGE =
    MidiMessage_MessageTypes_PUBLISHED_MESSAGE;
  static const MessageTypes SUBSCRIBE_REQUEST =
    MidiMessage_MessageTypes_SUBSCRIBE_REQUEST;
  static inline bool MessageTypes_IsValid(int value) {
    return MidiMessage_MessageTypes_IsValid(value);
  }
  static const MessageTypes MessageTypes_MIN =
    MidiMessage_MessageTypes_MessageTypes_MIN;
  static const MessageTypes MessageTypes_MAX =
    MidiMessage_MessageTypes_MessageTypes_MAX;
  static const int MessageTypes_ARRAYSIZE =
    MidiMessage_MessageTypes_MessageTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageTypes_descriptor() {
    return MidiMessage_MessageTypes_descriptor();
  }
  static inline const ::std::string& MessageTypes_Name(MessageTypes value) {
    return MidiMessage_MessageTypes_Name(value);
  }
  static inline bool MessageTypes_Parse(const ::std::string& name,
      MessageTypes* value) {
    return MidiMessage_MessageTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string message_id = 1;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // string last_message = 2;
  void clear_last_message();
  static const int kLastMessageFieldNumber = 2;
  const ::std::string& last_message() const;
  void set_last_message(const ::std::string& value);
  #if LANG_CXX11
  void set_last_message(::std::string&& value);
  #endif
  void set_last_message(const char* value);
  void set_last_message(const char* value, size_t size);
  ::std::string* mutable_last_message();
  ::std::string* release_last_message();
  void set_allocated_last_message(::std::string* last_message);

  // .MidiMessage.MessageTypes message_type = 5;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 5;
  ::MidiMessage_MessageTypes message_type() const;
  void set_message_type(::MidiMessage_MessageTypes value);

  // .MessageMetadata message_metadata = 6;
  bool has_message_metadata() const;
  void clear_message_metadata();
  static const int kMessageMetadataFieldNumber = 6;
  private:
  const ::MessageMetadata& _internal_message_metadata() const;
  public:
  const ::MessageMetadata& message_metadata() const;
  ::MessageMetadata* release_message_metadata();
  ::MessageMetadata* mutable_message_metadata();
  void set_allocated_message_metadata(::MessageMetadata* message_metadata);

  // .Error error = 7;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 7;
  private:
  const ::Error& _internal_error() const;
  public:
  const ::Error& error() const;
  ::Error* release_error();
  ::Error* mutable_error();
  void set_allocated_error(::Error* error);

  // .MidiData midi_data = 8;
  bool has_midi_data() const;
  void clear_midi_data();
  static const int kMidiDataFieldNumber = 8;
  private:
  const ::MidiData& _internal_midi_data() const;
  public:
  const ::MidiData& midi_data() const;
  ::MidiData* release_midi_data();
  ::MidiData* mutable_midi_data();
  void set_allocated_midi_data(::MidiData* midi_data);

  // string acked_message = 9;
  private:
  bool has_acked_message() const;
  public:
  void clear_acked_message();
  static const int kAckedMessageFieldNumber = 9;
  const ::std::string& acked_message() const;
  void set_acked_message(const ::std::string& value);
  #if LANG_CXX11
  void set_acked_message(::std::string&& value);
  #endif
  void set_acked_message(const char* value);
  void set_acked_message(const char* value, size_t size);
  ::std::string* mutable_acked_message();
  ::std::string* release_acked_message();
  void set_allocated_acked_message(::std::string* acked_message);

  // .PortList ports = 10;
  bool has_ports() const;
  void clear_ports();
  static const int kPortsFieldNumber = 10;
  private:
  const ::PortList& _internal_ports() const;
  public:
  const ::PortList& ports() const;
  ::PortList* release_ports();
  ::PortList* mutable_ports();
  void set_allocated_ports(::PortList* ports);

  // .PublishedMessage published_message = 11;
  bool has_published_message() const;
  void clear_published_message();
  static const int kPublishedMessageFieldNumber = 11;
  private:
  const ::PublishedMessage& _internal_published_message() const;
  public:
  const ::PublishedMessage& published_message() const;
  ::PublishedMessage* release_published_message();
  ::PublishedMessage* mutable_published_message();
  void set_allocated_published_message(::PublishedMessage* published_message);

  // .SubscribeRequest subscribe_request = 12;
  bool has_subscribe_request() const;
  void clear_subscribe_request();
  static const int kSubscribeRequestFieldNumber = 12;
  private:
  const ::SubscribeRequest& _internal_subscribe_request() const;
  public:
  const ::SubscribeRequest& subscribe_request() const;
  ::SubscribeRequest* release_subscribe_request();
  ::SubscribeRequest* mutable_subscribe_request();
  void set_allocated_subscribe_request(::SubscribeRequest* subscribe_request);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:MidiMessage)
 private:
  void set_has_message_metadata();
  void set_has_error();
  void set_has_midi_data();
  void set_has_acked_message();
  void set_has_ports();
  void set_has_published_message();
  void set_has_subscribe_request();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::google::protobuf::internal::ArenaStringPtr last_message_;
  int message_type_;
  union PayloadUnion {
    PayloadUnion() {}
    ::MessageMetadata* message_metadata_;
    ::Error* error_;
    ::MidiData* midi_data_;
    ::google::protobuf::internal::ArenaStringPtr acked_message_;
    ::PortList* ports_;
    ::PublishedMessage* published_message_;
    ::SubscribeRequest* subscribe_request_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_midimessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PortDescription

// .PortDescription.Direction direction = 1;
inline void PortDescription::clear_direction() {
  direction_ = 0;
}
inline ::PortDescription_Direction PortDescription::direction() const {
  // @@protoc_insertion_point(field_get:PortDescription.direction)
  return static_cast< ::PortDescription_Direction >(direction_);
}
inline void PortDescription::set_direction(::PortDescription_Direction value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:PortDescription.direction)
}

// string name = 2;
inline void PortDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortDescription::name() const {
  // @@protoc_insertion_point(field_get:PortDescription.name)
  return name_.GetNoArena();
}
inline void PortDescription::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PortDescription.name)
}
#if LANG_CXX11
inline void PortDescription::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PortDescription.name)
}
#endif
inline void PortDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PortDescription.name)
}
inline void PortDescription::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PortDescription.name)
}
inline ::std::string* PortDescription::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:PortDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortDescription::release_name() {
  // @@protoc_insertion_point(field_release:PortDescription.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:PortDescription.name)
}

// bool create_dynamic = 3;
inline void PortDescription::clear_create_dynamic() {
  create_dynamic_ = false;
}
inline bool PortDescription::create_dynamic() const {
  // @@protoc_insertion_point(field_get:PortDescription.create_dynamic)
  return create_dynamic_;
}
inline void PortDescription::set_create_dynamic(bool value) {
  
  create_dynamic_ = value;
  // @@protoc_insertion_point(field_set:PortDescription.create_dynamic)
}

// int32 key = 4;
inline void PortDescription::clear_key() {
  key_ = 0;
}
inline ::google::protobuf::int32 PortDescription::key() const {
  // @@protoc_insertion_point(field_get:PortDescription.key)
  return key_;
}
inline void PortDescription::set_key(::google::protobuf::int32 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:PortDescription.key)
}

// -------------------------------------------------------------------

// PortList

// repeated .PortDescription ports = 1;
inline int PortList::ports_size() const {
  return ports_.size();
}
inline void PortList::clear_ports() {
  ports_.Clear();
}
inline ::PortDescription* PortList::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:PortList.ports)
  return ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PortDescription >*
PortList::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:PortList.ports)
  return &ports_;
}
inline const ::PortDescription& PortList::ports(int index) const {
  // @@protoc_insertion_point(field_get:PortList.ports)
  return ports_.Get(index);
}
inline ::PortDescription* PortList::add_ports() {
  // @@protoc_insertion_point(field_add:PortList.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PortDescription >&
PortList::ports() const {
  // @@protoc_insertion_point(field_list:PortList.ports)
  return ports_;
}

// -------------------------------------------------------------------

// PublishedMessage

// string topic = 1;
inline void PublishedMessage::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublishedMessage::topic() const {
  // @@protoc_insertion_point(field_get:PublishedMessage.topic)
  return topic_.GetNoArena();
}
inline void PublishedMessage::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublishedMessage.topic)
}
#if LANG_CXX11
inline void PublishedMessage::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PublishedMessage.topic)
}
#endif
inline void PublishedMessage::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublishedMessage.topic)
}
inline void PublishedMessage::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublishedMessage.topic)
}
inline ::std::string* PublishedMessage::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:PublishedMessage.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublishedMessage::release_topic() {
  // @@protoc_insertion_point(field_release:PublishedMessage.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublishedMessage::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:PublishedMessage.topic)
}

// string sender = 2;
inline void PublishedMessage::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublishedMessage::sender() const {
  // @@protoc_insertion_point(field_get:PublishedMessage.sender)
  return sender_.GetNoArena();
}
inline void PublishedMessage::set_sender(const ::std::string& value) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublishedMessage.sender)
}
#if LANG_CXX11
inline void PublishedMessage::set_sender(::std::string&& value) {
  
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PublishedMessage.sender)
}
#endif
inline void PublishedMessage::set_sender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublishedMessage.sender)
}
inline void PublishedMessage::set_sender(const char* value, size_t size) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublishedMessage.sender)
}
inline ::std::string* PublishedMessage::mutable_sender() {
  
  // @@protoc_insertion_point(field_mutable:PublishedMessage.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublishedMessage::release_sender() {
  // @@protoc_insertion_point(field_release:PublishedMessage.sender)
  
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublishedMessage::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    
  } else {
    
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:PublishedMessage.sender)
}

// bytes message = 3;
inline void PublishedMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublishedMessage::message() const {
  // @@protoc_insertion_point(field_get:PublishedMessage.message)
  return message_.GetNoArena();
}
inline void PublishedMessage::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PublishedMessage.message)
}
#if LANG_CXX11
inline void PublishedMessage::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PublishedMessage.message)
}
#endif
inline void PublishedMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PublishedMessage.message)
}
inline void PublishedMessage::set_message(const void* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PublishedMessage.message)
}
inline ::std::string* PublishedMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:PublishedMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublishedMessage::release_message() {
  // @@protoc_insertion_point(field_release:PublishedMessage.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublishedMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:PublishedMessage.message)
}

// -------------------------------------------------------------------

// SubscribeRequest

// string topic = 1;
inline void SubscribeRequest::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscribeRequest::topic() const {
  // @@protoc_insertion_point(field_get:SubscribeRequest.topic)
  return topic_.GetNoArena();
}
inline void SubscribeRequest::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubscribeRequest.topic)
}
#if LANG_CXX11
inline void SubscribeRequest::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SubscribeRequest.topic)
}
#endif
inline void SubscribeRequest::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubscribeRequest.topic)
}
inline void SubscribeRequest::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubscribeRequest.topic)
}
inline ::std::string* SubscribeRequest::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:SubscribeRequest.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeRequest::release_topic() {
  // @@protoc_insertion_point(field_release:SubscribeRequest.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRequest::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:SubscribeRequest.topic)
}

// string requestNode = 2;
inline void SubscribeRequest::clear_requestnode() {
  requestnode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscribeRequest::requestnode() const {
  // @@protoc_insertion_point(field_get:SubscribeRequest.requestNode)
  return requestnode_.GetNoArena();
}
inline void SubscribeRequest::set_requestnode(const ::std::string& value) {
  
  requestnode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubscribeRequest.requestNode)
}
#if LANG_CXX11
inline void SubscribeRequest::set_requestnode(::std::string&& value) {
  
  requestnode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SubscribeRequest.requestNode)
}
#endif
inline void SubscribeRequest::set_requestnode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  requestnode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubscribeRequest.requestNode)
}
inline void SubscribeRequest::set_requestnode(const char* value, size_t size) {
  
  requestnode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubscribeRequest.requestNode)
}
inline ::std::string* SubscribeRequest::mutable_requestnode() {
  
  // @@protoc_insertion_point(field_mutable:SubscribeRequest.requestNode)
  return requestnode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeRequest::release_requestnode() {
  // @@protoc_insertion_point(field_release:SubscribeRequest.requestNode)
  
  return requestnode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRequest::set_allocated_requestnode(::std::string* requestnode) {
  if (requestnode != NULL) {
    
  } else {
    
  }
  requestnode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requestnode);
  // @@protoc_insertion_point(field_set_allocated:SubscribeRequest.requestNode)
}

// bool is_subscription = 3;
inline void SubscribeRequest::clear_is_subscription() {
  is_subscription_ = false;
}
inline bool SubscribeRequest::is_subscription() const {
  // @@protoc_insertion_point(field_get:SubscribeRequest.is_subscription)
  return is_subscription_;
}
inline void SubscribeRequest::set_is_subscription(bool value) {
  
  is_subscription_ = value;
  // @@protoc_insertion_point(field_set:SubscribeRequest.is_subscription)
}

// -------------------------------------------------------------------

// MessageMetadata

// uint32 port = 1;
inline void MessageMetadata::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 MessageMetadata::port() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.port)
  return port_;
}
inline void MessageMetadata::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:MessageMetadata.port)
}

// string host = 2;
inline void MessageMetadata::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageMetadata::host() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.host)
  return host_.GetNoArena();
}
inline void MessageMetadata::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageMetadata.host)
}
#if LANG_CXX11
inline void MessageMetadata::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MessageMetadata.host)
}
#endif
inline void MessageMetadata::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageMetadata.host)
}
inline void MessageMetadata::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageMetadata.host)
}
inline ::std::string* MessageMetadata::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:MessageMetadata.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageMetadata::release_host() {
  // @@protoc_insertion_point(field_release:MessageMetadata.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageMetadata::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.host)
}

// string friendly_name = 3;
inline void MessageMetadata::clear_friendly_name() {
  friendly_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageMetadata::friendly_name() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.friendly_name)
  return friendly_name_.GetNoArena();
}
inline void MessageMetadata::set_friendly_name(const ::std::string& value) {
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageMetadata.friendly_name)
}
#if LANG_CXX11
inline void MessageMetadata::set_friendly_name(::std::string&& value) {
  
  friendly_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MessageMetadata.friendly_name)
}
#endif
inline void MessageMetadata::set_friendly_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageMetadata.friendly_name)
}
inline void MessageMetadata::set_friendly_name(const char* value, size_t size) {
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageMetadata.friendly_name)
}
inline ::std::string* MessageMetadata::mutable_friendly_name() {
  
  // @@protoc_insertion_point(field_mutable:MessageMetadata.friendly_name)
  return friendly_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageMetadata::release_friendly_name() {
  // @@protoc_insertion_point(field_release:MessageMetadata.friendly_name)
  
  return friendly_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageMetadata::set_allocated_friendly_name(::std::string* friendly_name) {
  if (friendly_name != NULL) {
    
  } else {
    
  }
  friendly_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendly_name);
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.friendly_name)
}

// bool is_master = 4;
inline void MessageMetadata::clear_is_master() {
  is_master_ = false;
}
inline bool MessageMetadata::is_master() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.is_master)
  return is_master_;
}
inline void MessageMetadata::set_is_master(bool value) {
  
  is_master_ = value;
  // @@protoc_insertion_point(field_set:MessageMetadata.is_master)
}

// string software_package = 5;
inline void MessageMetadata::clear_software_package() {
  software_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageMetadata::software_package() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.software_package)
  return software_package_.GetNoArena();
}
inline void MessageMetadata::set_software_package(const ::std::string& value) {
  
  software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageMetadata.software_package)
}
#if LANG_CXX11
inline void MessageMetadata::set_software_package(::std::string&& value) {
  
  software_package_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MessageMetadata.software_package)
}
#endif
inline void MessageMetadata::set_software_package(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageMetadata.software_package)
}
inline void MessageMetadata::set_software_package(const char* value, size_t size) {
  
  software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageMetadata.software_package)
}
inline ::std::string* MessageMetadata::mutable_software_package() {
  
  // @@protoc_insertion_point(field_mutable:MessageMetadata.software_package)
  return software_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageMetadata::release_software_package() {
  // @@protoc_insertion_point(field_release:MessageMetadata.software_package)
  
  return software_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageMetadata::set_allocated_software_package(::std::string* software_package) {
  if (software_package != NULL) {
    
  } else {
    
  }
  software_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), software_package);
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.software_package)
}

// string software_version = 6;
inline void MessageMetadata::clear_software_version() {
  software_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageMetadata::software_version() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.software_version)
  return software_version_.GetNoArena();
}
inline void MessageMetadata::set_software_version(const ::std::string& value) {
  
  software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageMetadata.software_version)
}
#if LANG_CXX11
inline void MessageMetadata::set_software_version(::std::string&& value) {
  
  software_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MessageMetadata.software_version)
}
#endif
inline void MessageMetadata::set_software_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageMetadata.software_version)
}
inline void MessageMetadata::set_software_version(const char* value, size_t size) {
  
  software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageMetadata.software_version)
}
inline ::std::string* MessageMetadata::mutable_software_version() {
  
  // @@protoc_insertion_point(field_mutable:MessageMetadata.software_version)
  return software_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageMetadata::release_software_version() {
  // @@protoc_insertion_point(field_release:MessageMetadata.software_version)
  
  return software_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageMetadata::set_allocated_software_version(::std::string* software_version) {
  if (software_version != NULL) {
    
  } else {
    
  }
  software_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), software_version);
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.software_version)
}

// .PortList ports = 7;
inline bool MessageMetadata::has_ports() const {
  return this != internal_default_instance() && ports_ != NULL;
}
inline void MessageMetadata::clear_ports() {
  if (GetArenaNoVirtual() == NULL && ports_ != NULL) {
    delete ports_;
  }
  ports_ = NULL;
}
inline const ::PortList& MessageMetadata::_internal_ports() const {
  return *ports_;
}
inline const ::PortList& MessageMetadata::ports() const {
  const ::PortList* p = ports_;
  // @@protoc_insertion_point(field_get:MessageMetadata.ports)
  return p != NULL ? *p : *reinterpret_cast<const ::PortList*>(
      &::_PortList_default_instance_);
}
inline ::PortList* MessageMetadata::release_ports() {
  // @@protoc_insertion_point(field_release:MessageMetadata.ports)
  
  ::PortList* temp = ports_;
  ports_ = NULL;
  return temp;
}
inline ::PortList* MessageMetadata::mutable_ports() {
  
  if (ports_ == NULL) {
    auto* p = CreateMaybeMessage<::PortList>(GetArenaNoVirtual());
    ports_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MessageMetadata.ports)
  return ports_;
}
inline void MessageMetadata::set_allocated_ports(::PortList* ports) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ports_;
  }
  if (ports) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ports = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ports, submessage_arena);
    }
    
  } else {
    
  }
  ports_ = ports;
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.ports)
}

// -------------------------------------------------------------------

// Error

// string error_type = 1;
inline void Error::clear_error_type() {
  error_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::error_type() const {
  // @@protoc_insertion_point(field_get:Error.error_type)
  return error_type_.GetNoArena();
}
inline void Error::set_error_type(const ::std::string& value) {
  
  error_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Error.error_type)
}
#if LANG_CXX11
inline void Error::set_error_type(::std::string&& value) {
  
  error_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Error.error_type)
}
#endif
inline void Error::set_error_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Error.error_type)
}
inline void Error::set_error_type(const char* value, size_t size) {
  
  error_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Error.error_type)
}
inline ::std::string* Error::mutable_error_type() {
  
  // @@protoc_insertion_point(field_mutable:Error.error_type)
  return error_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_error_type() {
  // @@protoc_insertion_point(field_release:Error.error_type)
  
  return error_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_error_type(::std::string* error_type) {
  if (error_type != NULL) {
    
  } else {
    
  }
  error_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_type);
  // @@protoc_insertion_point(field_set_allocated:Error.error_type)
}

// .Error.ErrorSeverity severity = 2;
inline void Error::clear_severity() {
  severity_ = 0;
}
inline ::Error_ErrorSeverity Error::severity() const {
  // @@protoc_insertion_point(field_get:Error.severity)
  return static_cast< ::Error_ErrorSeverity >(severity_);
}
inline void Error::set_severity(::Error_ErrorSeverity value) {
  
  severity_ = value;
  // @@protoc_insertion_point(field_set:Error.severity)
}

// -------------------------------------------------------------------

// MidiData

// uint32 channel = 1;
inline void MidiData::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 MidiData::channel() const {
  // @@protoc_insertion_point(field_get:MidiData.channel)
  return channel_;
}
inline void MidiData::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:MidiData.channel)
}

// bytes data = 2;
inline void MidiData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MidiData::data() const {
  // @@protoc_insertion_point(field_get:MidiData.data)
  return data_.GetNoArena();
}
inline void MidiData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MidiData.data)
}
#if LANG_CXX11
inline void MidiData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MidiData.data)
}
#endif
inline void MidiData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MidiData.data)
}
inline void MidiData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MidiData.data)
}
inline ::std::string* MidiData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:MidiData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MidiData::release_data() {
  // @@protoc_insertion_point(field_release:MidiData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MidiData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:MidiData.data)
}

// -------------------------------------------------------------------

// MidiMessage

// string message_id = 1;
inline void MidiMessage::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MidiMessage::message_id() const {
  // @@protoc_insertion_point(field_get:MidiMessage.message_id)
  return message_id_.GetNoArena();
}
inline void MidiMessage::set_message_id(const ::std::string& value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MidiMessage.message_id)
}
#if LANG_CXX11
inline void MidiMessage::set_message_id(::std::string&& value) {
  
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MidiMessage.message_id)
}
#endif
inline void MidiMessage::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MidiMessage.message_id)
}
inline void MidiMessage::set_message_id(const char* value, size_t size) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MidiMessage.message_id)
}
inline ::std::string* MidiMessage::mutable_message_id() {
  
  // @@protoc_insertion_point(field_mutable:MidiMessage.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MidiMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:MidiMessage.message_id)
  
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MidiMessage::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    
  } else {
    
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:MidiMessage.message_id)
}

// string last_message = 2;
inline void MidiMessage::clear_last_message() {
  last_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MidiMessage::last_message() const {
  // @@protoc_insertion_point(field_get:MidiMessage.last_message)
  return last_message_.GetNoArena();
}
inline void MidiMessage::set_last_message(const ::std::string& value) {
  
  last_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MidiMessage.last_message)
}
#if LANG_CXX11
inline void MidiMessage::set_last_message(::std::string&& value) {
  
  last_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MidiMessage.last_message)
}
#endif
inline void MidiMessage::set_last_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MidiMessage.last_message)
}
inline void MidiMessage::set_last_message(const char* value, size_t size) {
  
  last_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MidiMessage.last_message)
}
inline ::std::string* MidiMessage::mutable_last_message() {
  
  // @@protoc_insertion_point(field_mutable:MidiMessage.last_message)
  return last_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MidiMessage::release_last_message() {
  // @@protoc_insertion_point(field_release:MidiMessage.last_message)
  
  return last_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MidiMessage::set_allocated_last_message(::std::string* last_message) {
  if (last_message != NULL) {
    
  } else {
    
  }
  last_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_message);
  // @@protoc_insertion_point(field_set_allocated:MidiMessage.last_message)
}

// .MidiMessage.MessageTypes message_type = 5;
inline void MidiMessage::clear_message_type() {
  message_type_ = 0;
}
inline ::MidiMessage_MessageTypes MidiMessage::message_type() const {
  // @@protoc_insertion_point(field_get:MidiMessage.message_type)
  return static_cast< ::MidiMessage_MessageTypes >(message_type_);
}
inline void MidiMessage::set_message_type(::MidiMessage_MessageTypes value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:MidiMessage.message_type)
}

// .MessageMetadata message_metadata = 6;
inline bool MidiMessage::has_message_metadata() const {
  return payload_case() == kMessageMetadata;
}
inline void MidiMessage::set_has_message_metadata() {
  _oneof_case_[0] = kMessageMetadata;
}
inline void MidiMessage::clear_message_metadata() {
  if (has_message_metadata()) {
    delete payload_.message_metadata_;
    clear_has_payload();
  }
}
inline const ::MessageMetadata& MidiMessage::_internal_message_metadata() const {
  return *payload_.message_metadata_;
}
inline ::MessageMetadata* MidiMessage::release_message_metadata() {
  // @@protoc_insertion_point(field_release:MidiMessage.message_metadata)
  if (has_message_metadata()) {
    clear_has_payload();
      ::MessageMetadata* temp = payload_.message_metadata_;
    payload_.message_metadata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MessageMetadata& MidiMessage::message_metadata() const {
  // @@protoc_insertion_point(field_get:MidiMessage.message_metadata)
  return has_message_metadata()
      ? *payload_.message_metadata_
      : *reinterpret_cast< ::MessageMetadata*>(&::_MessageMetadata_default_instance_);
}
inline ::MessageMetadata* MidiMessage::mutable_message_metadata() {
  if (!has_message_metadata()) {
    clear_payload();
    set_has_message_metadata();
    payload_.message_metadata_ = CreateMaybeMessage< ::MessageMetadata >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MidiMessage.message_metadata)
  return payload_.message_metadata_;
}

// .Error error = 7;
inline bool MidiMessage::has_error() const {
  return payload_case() == kError;
}
inline void MidiMessage::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void MidiMessage::clear_error() {
  if (has_error()) {
    delete payload_.error_;
    clear_has_payload();
  }
}
inline const ::Error& MidiMessage::_internal_error() const {
  return *payload_.error_;
}
inline ::Error* MidiMessage::release_error() {
  // @@protoc_insertion_point(field_release:MidiMessage.error)
  if (has_error()) {
    clear_has_payload();
      ::Error* temp = payload_.error_;
    payload_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Error& MidiMessage::error() const {
  // @@protoc_insertion_point(field_get:MidiMessage.error)
  return has_error()
      ? *payload_.error_
      : *reinterpret_cast< ::Error*>(&::_Error_default_instance_);
}
inline ::Error* MidiMessage::mutable_error() {
  if (!has_error()) {
    clear_payload();
    set_has_error();
    payload_.error_ = CreateMaybeMessage< ::Error >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MidiMessage.error)
  return payload_.error_;
}

// .MidiData midi_data = 8;
inline bool MidiMessage::has_midi_data() const {
  return payload_case() == kMidiData;
}
inline void MidiMessage::set_has_midi_data() {
  _oneof_case_[0] = kMidiData;
}
inline void MidiMessage::clear_midi_data() {
  if (has_midi_data()) {
    delete payload_.midi_data_;
    clear_has_payload();
  }
}
inline const ::MidiData& MidiMessage::_internal_midi_data() const {
  return *payload_.midi_data_;
}
inline ::MidiData* MidiMessage::release_midi_data() {
  // @@protoc_insertion_point(field_release:MidiMessage.midi_data)
  if (has_midi_data()) {
    clear_has_payload();
      ::MidiData* temp = payload_.midi_data_;
    payload_.midi_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MidiData& MidiMessage::midi_data() const {
  // @@protoc_insertion_point(field_get:MidiMessage.midi_data)
  return has_midi_data()
      ? *payload_.midi_data_
      : *reinterpret_cast< ::MidiData*>(&::_MidiData_default_instance_);
}
inline ::MidiData* MidiMessage::mutable_midi_data() {
  if (!has_midi_data()) {
    clear_payload();
    set_has_midi_data();
    payload_.midi_data_ = CreateMaybeMessage< ::MidiData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MidiMessage.midi_data)
  return payload_.midi_data_;
}

// string acked_message = 9;
inline bool MidiMessage::has_acked_message() const {
  return payload_case() == kAckedMessage;
}
inline void MidiMessage::set_has_acked_message() {
  _oneof_case_[0] = kAckedMessage;
}
inline void MidiMessage::clear_acked_message() {
  if (has_acked_message()) {
    payload_.acked_message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& MidiMessage::acked_message() const {
  // @@protoc_insertion_point(field_get:MidiMessage.acked_message)
  if (has_acked_message()) {
    return payload_.acked_message_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void MidiMessage::set_acked_message(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MidiMessage.acked_message)
  if (!has_acked_message()) {
    clear_payload();
    set_has_acked_message();
    payload_.acked_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.acked_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MidiMessage.acked_message)
}
#if LANG_CXX11
inline void MidiMessage::set_acked_message(::std::string&& value) {
  // @@protoc_insertion_point(field_set:MidiMessage.acked_message)
  if (!has_acked_message()) {
    clear_payload();
    set_has_acked_message();
    payload_.acked_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.acked_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MidiMessage.acked_message)
}
#endif
inline void MidiMessage::set_acked_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_acked_message()) {
    clear_payload();
    set_has_acked_message();
    payload_.acked_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.acked_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MidiMessage.acked_message)
}
inline void MidiMessage::set_acked_message(const char* value, size_t size) {
  if (!has_acked_message()) {
    clear_payload();
    set_has_acked_message();
    payload_.acked_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.acked_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MidiMessage.acked_message)
}
inline ::std::string* MidiMessage::mutable_acked_message() {
  if (!has_acked_message()) {
    clear_payload();
    set_has_acked_message();
    payload_.acked_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:MidiMessage.acked_message)
  return payload_.acked_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MidiMessage::release_acked_message() {
  // @@protoc_insertion_point(field_release:MidiMessage.acked_message)
  if (has_acked_message()) {
    clear_has_payload();
    return payload_.acked_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void MidiMessage::set_allocated_acked_message(::std::string* acked_message) {
  if (!has_acked_message()) {
    payload_.acked_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (acked_message != NULL) {
    set_has_acked_message();
    payload_.acked_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), acked_message);
  }
  // @@protoc_insertion_point(field_set_allocated:MidiMessage.acked_message)
}

// .PortList ports = 10;
inline bool MidiMessage::has_ports() const {
  return payload_case() == kPorts;
}
inline void MidiMessage::set_has_ports() {
  _oneof_case_[0] = kPorts;
}
inline void MidiMessage::clear_ports() {
  if (has_ports()) {
    delete payload_.ports_;
    clear_has_payload();
  }
}
inline const ::PortList& MidiMessage::_internal_ports() const {
  return *payload_.ports_;
}
inline ::PortList* MidiMessage::release_ports() {
  // @@protoc_insertion_point(field_release:MidiMessage.ports)
  if (has_ports()) {
    clear_has_payload();
      ::PortList* temp = payload_.ports_;
    payload_.ports_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::PortList& MidiMessage::ports() const {
  // @@protoc_insertion_point(field_get:MidiMessage.ports)
  return has_ports()
      ? *payload_.ports_
      : *reinterpret_cast< ::PortList*>(&::_PortList_default_instance_);
}
inline ::PortList* MidiMessage::mutable_ports() {
  if (!has_ports()) {
    clear_payload();
    set_has_ports();
    payload_.ports_ = CreateMaybeMessage< ::PortList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MidiMessage.ports)
  return payload_.ports_;
}

// .PublishedMessage published_message = 11;
inline bool MidiMessage::has_published_message() const {
  return payload_case() == kPublishedMessage;
}
inline void MidiMessage::set_has_published_message() {
  _oneof_case_[0] = kPublishedMessage;
}
inline void MidiMessage::clear_published_message() {
  if (has_published_message()) {
    delete payload_.published_message_;
    clear_has_payload();
  }
}
inline const ::PublishedMessage& MidiMessage::_internal_published_message() const {
  return *payload_.published_message_;
}
inline ::PublishedMessage* MidiMessage::release_published_message() {
  // @@protoc_insertion_point(field_release:MidiMessage.published_message)
  if (has_published_message()) {
    clear_has_payload();
      ::PublishedMessage* temp = payload_.published_message_;
    payload_.published_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::PublishedMessage& MidiMessage::published_message() const {
  // @@protoc_insertion_point(field_get:MidiMessage.published_message)
  return has_published_message()
      ? *payload_.published_message_
      : *reinterpret_cast< ::PublishedMessage*>(&::_PublishedMessage_default_instance_);
}
inline ::PublishedMessage* MidiMessage::mutable_published_message() {
  if (!has_published_message()) {
    clear_payload();
    set_has_published_message();
    payload_.published_message_ = CreateMaybeMessage< ::PublishedMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MidiMessage.published_message)
  return payload_.published_message_;
}

// .SubscribeRequest subscribe_request = 12;
inline bool MidiMessage::has_subscribe_request() const {
  return payload_case() == kSubscribeRequest;
}
inline void MidiMessage::set_has_subscribe_request() {
  _oneof_case_[0] = kSubscribeRequest;
}
inline void MidiMessage::clear_subscribe_request() {
  if (has_subscribe_request()) {
    delete payload_.subscribe_request_;
    clear_has_payload();
  }
}
inline const ::SubscribeRequest& MidiMessage::_internal_subscribe_request() const {
  return *payload_.subscribe_request_;
}
inline ::SubscribeRequest* MidiMessage::release_subscribe_request() {
  // @@protoc_insertion_point(field_release:MidiMessage.subscribe_request)
  if (has_subscribe_request()) {
    clear_has_payload();
      ::SubscribeRequest* temp = payload_.subscribe_request_;
    payload_.subscribe_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SubscribeRequest& MidiMessage::subscribe_request() const {
  // @@protoc_insertion_point(field_get:MidiMessage.subscribe_request)
  return has_subscribe_request()
      ? *payload_.subscribe_request_
      : *reinterpret_cast< ::SubscribeRequest*>(&::_SubscribeRequest_default_instance_);
}
inline ::SubscribeRequest* MidiMessage::mutable_subscribe_request() {
  if (!has_subscribe_request()) {
    clear_payload();
    set_has_subscribe_request();
    payload_.subscribe_request_ = CreateMaybeMessage< ::SubscribeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MidiMessage.subscribe_request)
  return payload_.subscribe_request_;
}

inline bool MidiMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MidiMessage::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MidiMessage::PayloadCase MidiMessage::payload_case() const {
  return MidiMessage::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PortDescription_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PortDescription_Direction>() {
  return ::PortDescription_Direction_descriptor();
}
template <> struct is_proto_enum< ::Error_ErrorSeverity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Error_ErrorSeverity>() {
  return ::Error_ErrorSeverity_descriptor();
}
template <> struct is_proto_enum< ::MidiMessage_MessageTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MidiMessage_MessageTypes>() {
  return ::MidiMessage_MessageTypes_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_midimessage_2eproto
